<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>Ant Colony — Homing Avoids Repellent (Border Walls)</title>
<style>
  body { font-family: Inter, Arial, sans-serif; background:#071018; color:#dfeef7; margin:0; display:flex; }
  #ui { width:460px; padding:14px; background:#06121a; box-shadow:6px 0 30px rgba(0,0,0,.6); overflow:auto; max-height:100vh; }
  canvas { background:#071018; display:block; margin:12px; border:1px solid #15202b; }
  label { font-size:13px; color:#9fb3c6; display:block; margin-top:10px; }
  input[type=range] { width:100%; }
  button { margin-top:10px; padding:8px 12px; background:#0ea5a4; color:#032; border:none; border-radius:6px; cursor:pointer; }
  .row { display:flex; gap:8px; align-items:center; margin-top:8px; }
  .hint { font-size:12px; color:#8da9b9; margin-top:6px; }
  .stat { font-size:13px; color:#cfe8f1; margin-top:6px; }
  hr { border:0; border-top:1px solid #123; margin:10px 0; }
</style>
</head>
<body>
  <div id="ui">
    <h2 style="margin:0 0 6px 0; color:#dff3ea;">Ant Colony — Homing Avoids Repellent</h2>
    <div class="row"><button id="resetBtn">Reset</button><button id="toggleSim">Pause</button></div>

    <label>Ants: <span id="numAntsLabel"></span></label>
    <input id="numAnts" type="range" min="10" max="3000" value="600">

    <label>Carrying deposit (trail): <span id="pdLabel"></span></label>
    <input id="pheromoneDeposit" type="range" min="0.01" max="1" step="0.01" value="0.22">

    <label>Baseline deposit (explore): <span id="baseLabel"></span></label>
    <input id="baselineDeposit" type="range" min="0.000" max="0.5" step="0.001" value="0.00">

    <label>Evaporation (trail): <span id="evapLabel"></span></label>
    <input id="evap" type="range" min="0.90" max="0.999" step="0.001" value="0.988">

    <label>Leak (trail): <span id="leakLabel"></span></label>
    <input id="leak" type="range" min="0.000" max="0.01" step="0.0005" value="0.0005">

    <hr>

    <label>Super-beacon deposit (burst at find): <span id="superDepLabel"></span></label>
    <input id="superDeposit" type="range" min="0.01" max="6.0" step="0.01" value="1.850">

    <label>Super evaporation multiplier: <span id="superEvapLabel"></span></label>
    <input id="superEvap" type="range" min="0.90" max="0.9999" step="0.0001" value="0.995">

    <label>Super leak: <span id="superLeakLabel"></span></label>
    <input id="superLeak" type="range" min="0.0000" max="0.01" step="0.0001" value="0.0001">

    <label>Super weight in sensing: <span id="superWeightLabel"></span></label>
    <input id="superWeight" type="range" min="0.0" max="20.0" step="0.1" value="10.20">

    <hr>

    <label>Repellent deposit on wall-hit: <span id="repelDepLabel"></span></label>
    <input id="repelDeposit" type="range" min="0.0" max="1.5" step="0.001" value="0.499">

    <label>Repellent halo factor (neighbors on collision): <span id="repelHaloLabel"></span></label>
    <input id="repelHalo" type="range" min="0.0" max="1.0" step="0.01" value="0.69">

    <label>Repellent evaporation multiplier: <span id="repelEvapLabel"></span></label>
    <input id="repelEvap" type="range" min="0.90" max="0.999" step="0.001" value="0.984">

    <label>Repellent leak: <span id="repelLeakLabel"></span></label>
    <input id="repelLeak" type="range" min="0.000" max="0.02" step="0.0005" value="0.0005">

    <label>Repellent weight in sensing: <span id="repelWeightLabel"></span></label>
    <input id="repelWeight" type="range" min="0.0" max="8.0" step="0.01" value="5.38">

    <hr>
    <label>Exploration (noise): <span id="explLabel"></span></label>
    <input id="expl" type="range" min="0.0" max="1.0" step="0.01" value="0.24">

    <label>Sensor range: <span id="sensLabel"></span></label>
    <input id="sensorRange" type="range" min="4" max="40" value="18">

    <hr>
    <div class="stat">Trail mass: <span id="trailMass">0</span></div>
    <div class="stat">Beacon mass: <span id="beaconMass">0</span></div>
    <div class="stat">Repel mass: <span id="repelMass">0</span></div>
    <div class="stat">Wall hits (since reset): <span id="wallHits">0</span></div>
    <div class="stat">Total beacon deposits: <span id="beaconDeposits">0</span></div>
    <div class="stat">Total repel deposits: <span id="repelDeposits">0</span></div>

    <div class="hint">Left-click drag to draw obstacles. Right-click to move food. Nest = green • Food = red</div>
  </div>

  <canvas id="c" style="width:1000px; height:640px;"></canvas>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  // UI nodes
  const numAntsInput = document.getElementById('numAnts');
  const pheromoneDepositInput = document.getElementById('pheromoneDeposit');
  const baselineDepositInput = document.getElementById('baselineDeposit');
  const evapInput = document.getElementById('evap');
  const leakInput = document.getElementById('leak');

  const superDepositInput = document.getElementById('superDeposit');
  const superEvapInput = document.getElementById('superEvap');
  const superLeakInput = document.getElementById('superLeak');
  const superWeightInput = document.getElementById('superWeight');

  const repelDepositInput = document.getElementById('repelDeposit');
  const repelHaloInput = document.getElementById('repelHalo');
  const repelEvapInput = document.getElementById('repelEvap');
  const repelLeakInput = document.getElementById('repelLeak');
  const repelWeightInput = document.getElementById('repelWeight');

  const explInput = document.getElementById('expl');
  const sensorRangeInput = document.getElementById('sensorRange');

  const resetBtn = document.getElementById('resetBtn');
  const toggleSim = document.getElementById('toggleSim');

  // diagnostics
  const trailMassElm = document.getElementById('trailMass');
  const beaconMassElm = document.getElementById('beaconMass');
  const repelMassElm = document.getElementById('repelMass');
  const wallHitsElm = document.getElementById('wallHits');
  const beaconDepositsElm = document.getElementById('beaconDeposits');
  const repelDepositsElm = document.getElementById('repelDeposits');

  // labels to update
  const pdLabel = document.getElementById('pdLabel');
  const baseLabel = document.getElementById('baseLabel');
  const evapLabel = document.getElementById('evapLabel');
  const leakLabel = document.getElementById('leakLabel');
  const superDepLabel = document.getElementById('superDepLabel');
  const superEvapLabel = document.getElementById('superEvapLabel');
  const superLeakLabel = document.getElementById('superLeakLabel');
  const superWeightLabel = document.getElementById('superWeightLabel');
  const repelDepLabel = document.getElementById('repelDepLabel');
  const repelHaloLabel = document.getElementById('repelHaloLabel');
  const repelEvapLabel = document.getElementById('repelEvapLabel');
  const repelLeakLabel = document.getElementById('repelLeakLabel');
  const repelWeightLabel = document.getElementById('repelWeightLabel');
  const explLabel = document.getElementById('explLabel');
  const sensLabel = document.getElementById('sensLabel');
  const numAntsLabel = document.getElementById('numAntsLabel');

  // canvas/grid (DPI-aware)
  let width = 0, height = 0;
  const gridSize = 100;
  let cols = gridSize, rows = 0;
  let cellW = 0, cellH = 0;
  function resizeCanvasAndGrid(){
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    const pixelW = Math.round(rect.width * dpr);
    const pixelH = Math.round(rect.height * dpr);
    if (canvas.width !== pixelW || canvas.height !== pixelH){
      canvas.width = pixelW; canvas.height = pixelH;
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    width = rect.width || 1;
    height = rect.height || 1;
    cols = gridSize;
    rows = Math.max(2, Math.round(gridSize * (height / width)));
    cellW = width / cols;
    cellH = height / rows;
  }

  // fields
  let pher = new Float32Array(1), repel = new Float32Array(1), superP = new Float32Array(1);
  function allocFields(){
    const len = Math.max(1, cols * rows);
    pher = new Float32Array(len);
    repel = new Float32Array(len);
    superP = new Float32Array(len);
  }

  // obstacles
  let obstacles = new Uint8Array(1);
  function resetObstaclesDefault(){
    // create empty grid then set border cells as walls
    obstacles = new Uint8Array(cols * rows);
    // fill border
    for (let x = 0; x < cols; x++){
      obstacles[x + 0 * cols] = 1; // top row
      obstacles[x + (rows - 1) * cols] = 1; // bottom row
    }
    for (let y = 0; y < rows; y++){
      obstacles[0 + y * cols] = 1; // left col
      obstacles[(cols - 1) + y * cols] = 1; // right col
    }
    // (no other default internal walls — you can draw them)
  }

  // nest & food
  let nest = {x:80,y:1}, food = {x:200,y:1};
  function placeDefaults(){
    resizeCanvasAndGrid();
    // ensure nest and food are placed away from the border walls (at least 1.5 cells inside)
    const margin = Math.max(2, Math.ceil(1.5));
    const left = margin * cellW + 8;
    const right = width - (margin * cellW) - 8;
    const midY = height / 2;
    nest = { x: Math.max(left, Math.min(width*0.12, right - 50)), y: midY };
    food = { x: Math.max(left + 120, right - 120), y: midY };
  }

  // ants
  let ants = [];
  function resetAnts(n){
    ants = [];
    for (let i=0;i<n;i++){
      ants.push({
        x: nest.x + (Math.random()*20-10),
        y: nest.y + (Math.random()*20-10),
        angle: Math.random()*Math.PI*2,
        carrying: false,
        speed: 1.6
      });
    }
  }

  // safe index helpers
  function idx(cx,cy){
    const x = Number.isFinite(cx) ? Math.floor(cx) : 0;
    const y = Number.isFinite(cy) ? Math.floor(cy) : 0;
    const xi = Math.max(0, Math.min(cols-1, x));
    const yi = Math.max(0, Math.min(rows-1, y));
    return xi + yi * cols;
  }
  function worldToCell(x,y){
    const cw = (cellW > 0 ? cellW : 1);
    const ch = (cellH > 0 ? cellH : 1);
    const cx = Math.floor((Number(x) || 0) / cw);
    const cy = Math.floor((Number(y) || 0) / ch);
    return { cx, cy };
  }

  // diagnostics
  let wallHitCount = 0;
  let totalBeaconDeposits = 0;
  let totalRepelDeposits = 0;

  // UI label updates
  function updateLabels(){
    numAntsLabel.textContent = numAntsInput.value;
    pdLabel.textContent = Number(pheromoneDepositInput.value).toFixed(3);
    baseLabel.textContent = Number(baselineDepositInput.value).toFixed(3);
    evapLabel.textContent = Number(evapInput.value).toFixed(3);
    leakLabel.textContent = Number(leakInput.value).toFixed(4);

    superDepLabel.textContent = Number(superDepositInput.value).toFixed(3);
    superEvapLabel.textContent = Number(superEvapInput.value).toFixed(4);
    superLeakLabel.textContent = Number(superLeakInput.value).toFixed(5);
    superWeightLabel.textContent = Number(superWeightInput.value).toFixed(2);

    repelDepLabel.textContent = Number(repelDepositInput.value).toFixed(3);
    repelHaloLabel.textContent = Number(repelHaloInput.value).toFixed(2);
    repelEvapLabel.textContent = Number(repelEvapInput.value).toFixed(3);
    repelLeakLabel.textContent = Number(repelLeakInput.value).toFixed(4);
    repelWeightLabel.textContent = Number(repelWeightInput.value).toFixed(2);

    explLabel.textContent = Number(explInput.value).toFixed(2);
    sensLabel.textContent = sensorRangeInput.value;
  }

  // robust local-direction search (prefer smallest angular deviation)
  function findBestFreeDirection(x,y,currentAngle,speed,shortRadius=4,longRadius=10,stepAngle= Math.PI/12, maxSteps=36){
    for (let s = 0; s <= maxSteps; s++){
      const sign = (s % 2 === 0) ? 1 : -1;
      const mag = Math.ceil((s+1)/2);
      const ang = currentAngle + sign * mag * stepAngle;
      const nx1 = x + Math.cos(ang) * Math.max(shortRadius, speed);
      const ny1 = y + Math.sin(ang) * Math.max(shortRadius, speed);
      const c1 = worldToCell(nx1, ny1);
      if (!obstacles[idx(c1.cx, c1.cy)]) return ang;
      const nx2 = x + Math.cos(ang) * Math.max(longRadius, speed*2);
      const ny2 = y + Math.sin(ang) * Math.max(longRadius, speed*2);
      const c2 = worldToCell(nx2, ny2);
      if (!obstacles[idx(c2.cx, c2.cy)]) return ang;
    }
    return null;
  }

  // If an ant is inside an obstacle cell, find nearest free neighbor (BFS perimeter up to radius)
  function escapeIfInsideObstacle(a){
    const c = worldToCell(a.x, a.y);
    const id = idx(c.cx, c.cy);
    if (!obstacles[id]) return false;
    const maxR = 4;
    for (let r=1; r<=maxR; r++){
      for (let dy = -r; dy <= r; dy++){
        for (let dx = -r; dx <= r; dx++){
          if (Math.abs(dx) !== r && Math.abs(dy) !== r) continue;
          const nx = c.cx + dx, ny = c.cy + dy;
          if (nx < 0 || ny < 0 || nx >= cols || ny >= rows) continue;
          const nid = idx(nx, ny);
          if (!obstacles[nid]){
            a.x = (nx + 0.5) * cellW;
            a.y = (ny + 0.5) * cellH;
            a.angle += Math.PI * 0.5;
            return true;
          }
        }
      }
    }
    a.x -= Math.cos(a.angle) * a.speed * 1.5;
    a.y -= Math.sin(a.angle) * a.speed * 1.5;
    a.angle += Math.PI * 0.6;
    return true;
  }

  // conservative candidate signal sampling (snapshot-based)
  function sampleCombinedSignalSnapshot(pherSnap, repelSnap, superSnap, x, y, ang, senseRange, superWeight, repelWeight){
    const dists = [ Math.max(2, senseRange*0.4), Math.max(4, senseRange) ];
    let minSig = Infinity;
    for (let dist of dists){
      const tx = x + Math.cos(ang) * dist;
      const ty = y + Math.sin(ang) * dist;
      const c = worldToCell(tx, ty);
      const idc = idx(c.cx, c.cy);
      if (obstacles[idc]) { minSig = Math.min(minSig, -1e6); continue; }
      const p = Number.isFinite(pherSnap[idc]) ? pherSnap[idc] : 0;
      const r = Number.isFinite(repelSnap[idc]) ? repelSnap[idc] : 0;
      const s = Number.isFinite(superSnap[idc]) ? superSnap[idc] : 0;
      const combined = superWeight * s + p - repelWeight * r;
      minSig = Math.min(minSig, combined);
    }
    return minSig;
  }

  // main simulation step
  function stepSim(){
    resizeCanvasAndGrid();

    // read UI
    const carryDeposit = Number(pheromoneDepositInput.value) || 0;
    const baselineDeposit = Number(baselineDepositInput.value) || 0;
    const evap = Number(evapInput.value) || 0.99;
    const leak = Number(leakInput.value) || 0;

    const superDeposit = Number(superDepositInput.value) || 0;
    const superEvap = Number(superEvapInput.value) || 0.995;
    const superLeak = Number(superLeakInput.value) || 0;
    const superWeight = Number(superWeightInput.value) || 0;

    const repelDeposit = Number(repelDepositInput.value) || 0;
    const repelHaloFactor = Number(repelHaloInput.value) || 0.5;
    const repelEvap = Number(repelEvapInput.value) || 0.95;
    const repelLeak = Number(repelLeakInput.value) || 0;
    const repelWeight = Number(repelWeightInput.value) || 1.8;

    const exploration = Number(explInput.value) || 0;
    const sensorRangeUI = Number(sensorRangeInput.value) || 10;

    const diffusionAlpha = 0.08;
    const obstaclePenalty = -1e6;

    // snapshots for sensing (so decisions don't see deposits from current tick)
    const pherSnap = pher.slice();
    const repelSnap = repel.slice();
    const superSnap = superP.slice();

    for (let a of ants){
      // pop out from inside obstacles if necessary
      if (escapeIfInsideObstacle(a)) {
        // continue to processing — ant has been nudged out
      }

      const isCarrying = !!a.carrying;
      const senseRange = isCarrying ? Math.max(6, sensorRangeUI * 1.6) : sensorRangeUI;
      const effectiveExpl = isCarrying ? Math.max(0.02, exploration * 0.16) : exploration;

      // current combined signal using snapshot (super + trail - repel)
      const curCell = worldToCell(a.x, a.y);
      const curIdx = idx(curCell.cx, curCell.cy);
      const curP = Number.isFinite(pherSnap[curIdx]) ? pherSnap[curIdx] : 0;
      const curR = Number.isFinite(repelSnap[curIdx]) ? repelSnap[curIdx] : 0;
      const curS = Number.isFinite(superSnap[curIdx]) ? superSnap[curIdx] : 0;
      const curSignal = superWeight * curS + curP - repelWeight * curR;

      // evaluate candidate headings
      let candidates = [];
      if (!isCarrying){
        candidates = [-0.6, 0, 0.6].map(aoff => a.angle + aoff);
      } else {
        const angToNest = Math.atan2(nest.y - a.y, nest.x - a.x);
        const offsets = [0, 0.25, -0.25, 0.5, -0.5, 0.9, -0.9];
        candidates = offsets.map(off => angToNest + off);
        candidates.push(a.angle, a.angle + 0.4, a.angle - 0.4);
      }

      let bestAngle = a.angle;
      let bestDiff = -Infinity;
      for (let candAng of candidates){
        const sig = sampleCombinedSignalSnapshot(pherSnap, repelSnap, superSnap, a.x, a.y, candAng, senseRange, superWeight, repelWeight);
        const diff = sig - curSignal;
        if (diff > bestDiff){
          bestDiff = diff; bestAngle = candAng;
        }
      }

      // Movement decision
      if (bestDiff > 0 && Math.random() > effectiveExpl){
        const jitter = isCarrying ? 0.12 : 0.25;
        a.angle = bestAngle + (Math.random()-0.5) * jitter;
      } else {
        if (isCarrying){
          const angToNest = Math.atan2(nest.y - a.y, nest.x - a.x);
          const testX = a.x + Math.cos(angToNest) * Math.max(6, a.speed*3);
          const testY = a.y + Math.sin(angToNest) * Math.max(6, a.speed*3);
          const tcell = worldToCell(testX, testY);
          const tIdx = idx(tcell.cx, tcell.cy);
          const tRepel = Number.isFinite(repelSnap[tIdx]) ? repelSnap[tIdx] : 0;
          if (!obstacles[tIdx] && tRepel * repelWeight < (curSignal + 1e-6)){
            a.angle = angToNest + (Math.random()-0.5) * 0.25;
          } else {
            if (bestDiff > -1e5){
              a.angle = bestAngle + (Math.random()-0.5) * 0.3;
            } else {
              const alt = findBestFreeDirection(a.x, a.y, a.angle, a.speed);
              if (alt !== null) a.angle = alt;
              else { a.x -= Math.cos(a.angle) * a.speed * 0.7; a.y -= Math.sin(a.angle) * a.speed * 0.7; a.angle += Math.PI * 0.45 * (Math.random() > 0.5 ? 1 : -1); }
            }
          }
        } else {
          a.angle += (Math.random()-0.5) * 0.8;
        }
      }

      // attempt move
      let nx = a.x + Math.cos(a.angle) * a.speed;
      let ny = a.y + Math.sin(a.angle) * a.speed;
      const c = worldToCell(nx, ny);
      const cIdx = idx(c.cx, c.cy);

      if (obstacles[cIdx]){
        // deposit repellent at obstacle cell
        if (cIdx >= 0 && cIdx < repel.length){
          const add = repelDepositInput ? Number(repelDepositInput.value) : 0.09;
          const newv = Number.isFinite(repel[cIdx]) ? repel[cIdx] + add : add;
          repel[cIdx] = Number.isFinite(newv) ? newv : 0;
          totalRepelDeposits += add;
        }
        wallHitCount++;
        // halo deposits
        if (repelHaloFactor > 0){
          const cx = Math.max(0, Math.min(cols-1, c.cx));
          const cy = Math.max(0, Math.min(rows-1, c.cy));
          for (let oy=-1; oy<=1; oy++){
            for (let ox=-1; ox<=1; ox++){
              const nxCell = cx + ox, nyCell = cy + oy;
              if (nxCell < 0 || nyCell < 0 || nxCell >= cols || nyCell >= rows) continue;
              const nId = idx(nxCell, nyCell);
              if (obstacles[nId]) continue;
              const add = repelDepositInput ? Number(repelDepositInput.value) * repelHaloFactor : repelHaloFactor * 0.09;
              const newv = Number.isFinite(repel[nId]) ? repel[nId] + add : add;
              repel[nId] = Number.isFinite(newv) ? newv : 0;
              totalRepelDeposits += add;
            }
          }
        }

        const alt = findBestFreeDirection(a.x, a.y, a.angle, a.speed);
        if (alt !== null){
          a.angle = alt;
          nx = a.x + Math.cos(a.angle) * a.speed;
          ny = a.y + Math.sin(a.angle) * a.speed;
          const cc = worldToCell(nx, ny);
          if (!obstacles[idx(cc.cx, cc.cy)]) {
            a.x = Math.max(2, Math.min(width-2, nx));
            a.y = Math.max(2, Math.min(height-2, ny));
          }
        } else {
          a.x -= Math.cos(a.angle) * a.speed * 0.7;
          a.y -= Math.sin(a.angle) * a.speed * 0.7;
          a.angle += Math.PI * 0.45 * (Math.random() > 0.5 ? 1 : -1);
        }
      } else {
        a.x = Math.max(2, Math.min(width-2, nx));
        a.y = Math.max(2, Math.min(height-2, ny));
      }

      // pickup/drop + beacon deposit (instant burst)
      const dFood = Math.hypot(a.x - food.x, a.y - food.y);
      if (!a.carrying && dFood < 6){
        a.carrying = true;
        const wc = worldToCell(a.x, a.y);
        const id = idx(wc.cx, wc.cy);
        if (id >= 0 && id < superP.length){
          const add = Number(superDepositInput.value);
          const newv = Number.isFinite(superP[id]) ? superP[id] + add : add;
          superP[id] = Number.isFinite(newv) ? newv : 0;
          totalBeaconDeposits += add;
        }
      }
      const dNest = Math.hypot(a.x - nest.x, a.y - nest.y);
      if (a.carrying && dNest < 8) a.carrying = false;

      // deposition: baseline + carry deposit
      const wc2 = worldToCell(a.x, a.y);
      const id2 = idx(wc2.cx, wc2.cy);
      if (id2 >= 0 && id2 < pher.length){
        const base = Number(baselineDepositInput.value);
        if (base > 0){
          pher[id2] = Number.isFinite(pher[id2]) ? (pher[id2] + base) : base;
        }
        if (a.carrying){
          const carry = Number(pheromoneDepositInput.value);
          pher[id2] = Number.isFinite(pher[id2]) ? (pher[id2] + carry) : carry;
        }
      }
    } // end ants loop

    // evaporation (apply to live arrays)
    for (let i=0;i<pher.length;i++){
      let v = Number.isFinite(pher[i]) ? pher[i] : 0;
      v = v * Number(evapInput.value) - Number(leakInput.value);
      if (!Number.isFinite(v) || v <= 0) v = 0;
      pher[i] = v;
    }
    for (let i=0;i<superP.length;i++){
      let v = Number.isFinite(superP[i]) ? superP[i] : 0;
      v = v * Number(superEvapInput.value) - Number(superLeakInput.value);
      if (!Number.isFinite(v) || v <= 0) v = 0;
      superP[i] = v;
    }
    for (let i=0;i<repel.length;i++){
      let v = Number.isFinite(repel[i]) ? repel[i] : 0;
      v = v * Number(repelEvapInput.value) - Number(repelLeakInput.value);
      if (!Number.isFinite(v) || v <= 0) v = 0;
      repel[i] = v;
    }

    // diffusion (gentle)
    const pcopy = pher.slice(), scap = superP.slice(), rcopy = repel.slice();
    for (let y=0;y<rows;y++){
      for (let x=0;x<cols;x++){
        const id = x + y * cols;
        let psum = pcopy[id], pcount = 1;
        let ssum = scap[id], scount = 1;
        let rsum = rcopy[id], rcount = 1;
        if (x>0){ psum += pcopy[id-1]; pcount++; ssum += scap[id-1]; scount++; rsum += rcopy[id-1]; rcount++; }
        if (x<cols-1){ psum += pcopy[id+1]; pcount++; ssum += scap[id+1]; scount++; rsum += rcopy[id+1]; rcount++; }
        if (y>0){ psum += pcopy[id-cols]; pcount++; ssum += scap[id-cols]; scount++; rsum += rcopy[id-cols]; rcount++; }
        if (y<rows-1){ psum += pcopy[id+cols]; pcount++; ssum += scap[id+cols]; scount++; rsum += rcopy[id+cols]; rcount++; }
        const pavg = psum / pcount, savg = ssum / scount, ravg = rsum / rcount;
        const alpha = diffusionAlpha;
        let newp = (Number.isFinite(pcopy[id]) ? pcopy[id] : 0) * (1 - alpha) + pavg * alpha;
        let news = (Number.isFinite(scap[id]) ? scap[id] : 0) * (1 - alpha) + savg * alpha;
        let newr = (Number.isFinite(rcopy[id]) ? rcopy[id] : 0) * (1 - alpha) + ravg * alpha;
        if (!Number.isFinite(newp) || newp <= 0) newp = 0;
        if (!Number.isFinite(news) || news <= 0) news = 0;
        if (!Number.isFinite(newr) || newr <= 0) newr = 0;
        pher[id] = newp;
        superP[id] = news;
        repel[id] = newr;
      }
    }

    // diagnostics after diffusion
    let trailMass = 0, beaconMass = 0, repelMass = 0;
    for (let i=0;i<pher.length;i++) trailMass += (Number.isFinite(pher[i]) ? pher[i] : 0);
    for (let i=0;i<superP.length;i++) beaconMass += (Number.isFinite(superP[i]) ? superP[i] : 0);
    for (let i=0;i<repel.length;i++) repelMass += (Number.isFinite(repel[i]) ? repel[i] : 0);

    trailMassElm.textContent = trailMass.toFixed(6);
    beaconMassElm.textContent = beaconMass.toFixed(6);
    repelMassElm.textContent = repelMass.toFixed(6);
    wallHitsElm.textContent = wallHitCount;
    beaconDepositsElm.textContent = totalBeaconDeposits.toFixed(3);
    repelDepositsElm.textContent = totalRepelDeposits.toFixed(3);
  }

  // draw (auto-normalize)
  function draw(){
    resizeCanvasAndGrid();
    ctx.clearRect(0,0,width,height);

    let maxTrail = 0, maxSuper = 0, maxRepel = 0;
    for (let i=0;i<pher.length;i++){
      const pv = Number.isFinite(pher[i]) ? pher[i] : 0;
      if (pv > maxTrail) maxTrail = pv;
      const sv = Number.isFinite(superP[i]) ? superP[i] : 0;
      if (sv > maxSuper) maxSuper = sv;
      const rv = Number.isFinite(repel[i]) ? repel[i] : 0;
      if (rv > maxRepel) maxRepel = rv;
    }

    // draw trail (orange)
    for (let y=0;y<rows;y++){
      for (let x=0;x<cols;x++){
        const i = x + y * cols;
        const v = Number.isFinite(pher[i]) ? pher[i] : 0;
        if (v > 0){
          const alpha = Math.min(1, v / (maxTrail || 1) * 0.9);
          ctx.fillStyle = `rgba(255,165,0,${alpha})`;
          ctx.fillRect(x*cellW, y*cellH, cellW, cellH);
        }
      }
    }
    // super beacon (purple)
    for (let y=0;y<rows;y++){
      for (let x=0;x<cols;x++){
        const i = x + y * cols;
        const v = Number.isFinite(superP[i]) ? superP[i] : 0;
        if (v > 0){
          const alpha = Math.min(1, v / (maxSuper || 1) * 0.95);
          ctx.fillStyle = `rgba(200,90,255,${alpha})`;
          ctx.fillRect(x*cellW, y*cellH, cellW, cellH);
        }
      }
    }
    // repellent (blue)
    for (let y=0;y<rows;y++){
      for (let x=0;x<cols;x++){
        const i = x + y * cols;
        const v = Number.isFinite(repel[i]) ? repel[i] : 0;
        if (v > 0){
          const alpha = Math.min(0.9, v / (maxRepel || 1) * 0.9);
          ctx.fillStyle = `rgba(60,150,255,${alpha})`;
          ctx.fillRect(x*cellW, y*cellH, cellW, cellH);
        }
      }
    }

    // obstacles (including border)
    ctx.fillStyle = '#333';
    for (let y=0;y<rows;y++){
      for (let x=0;x<cols;x++){
        if (obstacles[x + y*cols]) ctx.fillRect(x*cellW, y*cellH, cellW, cellH);
      }
    }

    // nest & food
    ctx.beginPath(); ctx.fillStyle = 'lime'; ctx.arc(nest.x, nest.y, 10, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.fillStyle = 'crimson'; ctx.arc(food.x, food.y, 10, 0, Math.PI*2); ctx.fill();

    // ants
    for (let a of ants){
      ctx.beginPath();
      ctx.fillStyle = a.carrying ? 'yellow' : 'white';
      ctx.arc(a.x, a.y, 3, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // main loop
  let running = true;
  function loop(){
    if (running){
      const desired = Number(numAntsInput.value) || 100;
      if (ants.length < desired) resetAnts(desired);
      else if (ants.length > desired) ants.length = desired;
      stepSim();
      draw();
    }
    requestAnimationFrame(loop);
  }

  // init/reset
  function resetAll(){
    resizeCanvasAndGrid();
    allocFields();
    placeDefaults();
    resetObstaclesDefault();
    resetAnts(Number(numAntsInput.value) || 600);
    wallHitCount = 0;
    totalBeaconDeposits = 0;
    totalRepelDeposits = 0;
  }
  resetAll();
  requestAnimationFrame(loop);

  // mouse interactions
  let drawing = false;
  canvas.addEventListener('pointerdown', (e) => { drawing = true; drawObstacleAt(e); });
  canvas.addEventListener('pointermove', (e) => { if (drawing) drawObstacleAt(e); });
  window.addEventListener('pointerup', () => drawing = false);
  function drawObstacleAt(e){
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const c = worldToCell(x, y);
    const id = idx(c.cx, c.cy);
    // do not allow drawing on the border (it is already a wall)
    if (id >= 0 && id < obstacles.length && c.cx > 0 && c.cx < cols-1 && c.cy > 0 && c.cy < rows-1) obstacles[id] = 1;
  }
  canvas.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    // ensure food placed inside border
    const c = worldToCell(x,y);
    if (c.cx > 0 && c.cx < cols-1 && c.cy > 0 && c.cy < rows-1){
      food.x = x; food.y = y;
    }
  });

  // UI bindings
  const uiElems = [numAntsInput, pheromoneDepositInput, baselineDepositInput, evapInput, leakInput,
                   superDepositInput, superEvapInput, superLeakInput, superWeightInput,
                   repelDepositInput, repelHaloInput, repelEvapInput, repelLeakInput, repelWeightInput,
                   explInput, sensorRangeInput];
  uiElems.forEach(el => el.addEventListener('input', updateLabels));
  resetBtn.addEventListener('click', () => { resetAll(); });
  toggleSim.addEventListener('click', () => { running = !running; toggleSim.textContent = running ? 'Pause' : 'Resume'; });

  updateLabels();
  resizeCanvasAndGrid();
})();
</script>
</body>
</html>

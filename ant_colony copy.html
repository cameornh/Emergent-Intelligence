<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>Ant Colony — Wall-Hugging Controller</title>
<style>
  body { font-family: Inter, Arial, sans-serif; background:#071018; color:#dfeef7; margin:0; display:flex; }
  #ui { width:520px; padding:14px; background:#06121a; box-shadow:6px 0 30px rgba(0,0,0,.6); }
  canvas { background:#071018; display:block; margin:12px; border:1px solid #15202b; }
  label { font-size:13px; color:#9fb3c6; display:block; margin-top:10px; }
  input[type=range] { width:100%; }
  button { margin-top:10px; padding:8px 12px; background:#0ea5a4; color:#032; border:none; border-radius:6px; cursor:pointer; }
  .row { display:flex; gap:8px; align-items:center; margin-top:8px; }
  .hint { font-size:12px; color:#8da9b9; margin-top:6px; }
  .stat { font-size:13px; color:#cfe8f1; margin-top:6px; }
  hr { border:0; border-top:1px solid #123; margin:10px 0; }
</style>
</head>
<body>
  <div id="ui">
    <h2 style="margin:0 0 6px 0; color:#dff3ea;">Ant Colony — Wall Hugging Controller</h2>
    <div class="row"><button id="resetBtn">Reset</button><button id="toggleSim">Pause</button></div>

    <label>Ants: <span id="numAntsLabel"></span></label>
    <input id="numAnts" type="range" min="10" max="600" value="120">

    <label>Carrying deposit (trail): <span id="pdLabel"></span></label>
    <input id="pheromoneDeposit" type="range" min="0.01" max="1" step="0.01" value="0.22">

    <label>Baseline deposit (explore): <span id="baseLabel"></span></label>
    <input id="baselineDeposit" type="range" min="0.000" max="0.5" step="0.001" value="0.03">

    <label>Evaporation (trail): <span id="evapLabel"></span></label>
    <input id="evap" type="range" min="0.90" max="0.999" step="0.001" value="0.985">

    <label>Leak (trail): <span id="leakLabel"></span></label>
    <input id="leak" type="range" min="0.000" max="0.01" step="0.0005" value="0.0004">

    <hr>

    <label>Super-beacon deposit (burst at find): <span id="superDepLabel"></span></label>
    <input id="superDeposit" type="range" min="0.01" max="6.0" step="0.01" value="1.4">

    <label>Super evaporation multiplier: <span id="superEvapLabel"></span></label>
    <input id="superEvap" type="range" min="0.90" max="0.9999" step="0.0001" value="0.995">

    <label>Super leak: <span id="superLeakLabel"></span></label>
    <input id="superLeak" type="range" min="0.0000" max="0.01" step="0.0001" value="0.00005">

    <label>Super weight in sensing: <span id="superWeightLabel"></span></label>
    <input id="superWeight" type="range" min="0.0" max="20.0" step="0.1" value="6.0">

    <hr>

    <label>Repellent deposit on wall-hit: <span id="repelDepLabel"></span></label>
    <input id="repelDeposit" type="range" min="0.0" max="1.5" step="0.001" value="0.09">

    <label>Repellent halo factor (neighbors on collision): <span id="repelHaloLabel"></span></label>
    <input id="repelHalo" type="range" min="0.0" max="1.0" step="0.01" value="0.5">

    <label>Repellent evaporation multiplier: <span id="repelEvapLabel"></span></label>
    <input id="repelEvap" type="range" min="0.90" max="0.999" step="0.001" value="0.95">

    <label>Repellent leak: <span id="repelLeakLabel"></span></label>
    <input id="repelLeak" type="range" min="0.000" max="0.02" step="0.0005" value="0.001">

    <label>Repellent weight in sensing: <span id="repelWeightLabel"></span></label>
    <input id="repelWeight" type="range" min="0.0" max="8.0" step="0.01" value="1.8">

    <hr>
    <label>Exploration (noise): <span id="explLabel"></span></label>
    <input id="expl" type="range" min="0.0" max="1.0" step="0.01" value="0.24">

    <label>Sensor range: <span id="sensLabel"></span></label>
    <input id="sensorRange" type="range" min="4" max="40" value="14">

    <hr>
    <div class="stat">Trail mass: <span id="trailMass">0</span></div>
    <div class="stat">Beacon mass: <span id="beaconMass">0</span></div>
    <div class="stat">Repel mass: <span id="repelMass">0</span></div>
    <div class="stat">Wall hits (since reset): <span id="wallHits">0</span></div>
    <div class="stat">Total beacon deposits: <span id="beaconDeposits">0</span></div>
    <div class="stat">Total repel deposits: <span id="repelDeposits">0</span></div>

    <div class="hint">Left-click drag to draw obstacles. Right-click to move food. Nest = green • Food = red</div>
  </div>

  <canvas id="c" style="width:1100px; height:680px;"></canvas>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  // UI nodes
  const numAntsInput = document.getElementById('numAnts');
  const pheromoneDepositInput = document.getElementById('pheromoneDeposit');
  const baselineDepositInput = document.getElementById('baselineDeposit');
  const evapInput = document.getElementById('evap');
  const leakInput = document.getElementById('leak');

  const superDepositInput = document.getElementById('superDeposit');
  const superEvapInput = document.getElementById('superEvap');
  const superLeakInput = document.getElementById('superLeak');
  const superWeightInput = document.getElementById('superWeight');

  const repelDepositInput = document.getElementById('repelDeposit');
  const repelHaloInput = document.getElementById('repelHalo');
  const repelEvapInput = document.getElementById('repelEvap');
  const repelLeakInput = document.getElementById('repelLeak');
  const repelWeightInput = document.getElementById('repelWeight');

  const explInput = document.getElementById('expl');
  const sensorRangeInput = document.getElementById('sensorRange');

  const resetBtn = document.getElementById('resetBtn');
  const toggleSim = document.getElementById('toggleSim');

  // diagnostics
  const trailMassElm = document.getElementById('trailMass');
  const beaconMassElm = document.getElementById('beaconMass');
  const repelMassElm = document.getElementById('repelMass');
  const wallHitsElm = document.getElementById('wallHits');
  const beaconDepositsElm = document.getElementById('beaconDeposits');
  const repelDepositsElm = document.getElementById('repelDeposits');

  // labels
  const pdLabel = document.getElementById('pdLabel');
  const baseLabel = document.getElementById('baseLabel');
  const evapLabel = document.getElementById('evapLabel');
  const leakLabel = document.getElementById('leakLabel');
  const superDepLabel = document.getElementById('superDepLabel');
  const superEvapLabel = document.getElementById('superEvapLabel');
  const superLeakLabel = document.getElementById('superLeakLabel');
  const superWeightLabel = document.getElementById('superWeightLabel');
  const repelDepLabel = document.getElementById('repelDepLabel');
  const repelHaloLabel = document.getElementById('repelHaloLabel');
  const repelEvapLabel = document.getElementById('repelEvapLabel');
  const repelLeakLabel = document.getElementById('repelLeakLabel');
  const repelWeightLabel = document.getElementById('repelWeightLabel');
  const explLabel = document.getElementById('explLabel');
  const sensLabel = document.getElementById('sensLabel');
  const numAntsLabel = document.getElementById('numAntsLabel');

  // canvas/grid sizing (DPI-aware)
  let width = 0, height = 0;
  const gridSize = 120;
  let cols = gridSize, rows = 0;
  let cellW = 0, cellH = 0;
  function resizeCanvasAndGrid(){
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    const pixelW = Math.round(rect.width * dpr);
    const pixelH = Math.round(rect.height * dpr);
    if (canvas.width !== pixelW || canvas.height !== pixelH){
      canvas.width = pixelW; canvas.height = pixelH;
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    width = rect.width || 1;
    height = rect.height || 1;
    cols = gridSize;
    rows = Math.max(2, Math.round(gridSize * (height / width)));
    cellW = width / cols;
    cellH = height / rows;
  }

  // fields
  let pher = new Float32Array(1), repel = new Float32Array(1), superP = new Float32Array(1);
  function allocFields(){
    const len = Math.max(1, cols * rows);
    pher = new Float32Array(len);
    repel = new Float32Array(len);
    superP = new Float32Array(len);
  }

  // obstacles
  let obstacles = new Uint8Array(1);
  function resetObstaclesDefault(){
    obstacles = new Uint8Array(cols * rows);
    const cx = Math.floor(cols/2), cy = Math.floor(rows/2);
    for (let y=0;y<rows;y++){
      const i = cx + y * cols;
      if (Math.abs(y - cy) > 6) obstacles[i] = 1;
    }
  }

  // nest & food
  let nest = {x:80,y:1}, food = {x:200,y:1};
  function placeDefaults(){
    resizeCanvasAndGrid();
    nest = { x: Math.max(80, width*0.08), y: height/2 };
    food = { x: Math.max(200, width - Math.max(180, width*0.12)), y: height/2 };
  }

  // ants
  let ants = [];
  function resetAnts(n){
    ants = [];
    for (let i=0;i<n;i++){
      ants.push({
        x: nest.x + (Math.random()*20-10),
        y: nest.y + (Math.random()*20-10),
        angle: Math.random()*Math.PI*2,
        carrying: false,
        speed: 1.6,
        // wall-hug state:
        hug: null // {side: 1|-1, angle, remaining, startCell, lastPositions: [{x,y}]}
      });
    }
  }

  // helpers
  function idx(cx,cy){
    const x = Number.isFinite(cx) ? Math.floor(cx) : 0;
    const y = Number.isFinite(cy) ? Math.floor(cy) : 0;
    const xi = Math.max(0, Math.min(cols-1, x));
    const yi = Math.max(0, Math.min(rows-1, y));
    return xi + yi * cols;
  }
  function worldToCell(x,y){
    const cw = (cellW > 0 ? cellW : 1);
    const ch = (cellH > 0 ? cellH : 1);
    const cx = Math.floor((Number(x) || 0) / cw);
    const cy = Math.floor((Number(y) || 0) / ch);
    return { cx, cy };
  }

  // diagnostics
  let wallHitCount = 0;
  let totalBeaconDeposits = 0;
  let totalRepelDeposits = 0;

  // UI labels
  function updateLabels(){
    numAntsLabel.textContent = numAntsInput.value;
    pdLabel.textContent = Number(pheromoneDepositInput.value).toFixed(3);
    baseLabel.textContent = Number(baselineDepositInput.value).toFixed(3);
    evapLabel.textContent = Number(evapInput.value).toFixed(3);
    leakLabel.textContent = Number(leakInput.value).toFixed(4);

    superDepLabel.textContent = Number(superDepositInput.value).toFixed(3);
    superEvapLabel.textContent = Number(superEvapInput.value).toFixed(4);
    superLeakLabel.textContent = Number(superLeakInput.value).toFixed(5);
    superWeightLabel.textContent = Number(superWeightInput.value).toFixed(2);

    repelDepLabel.textContent = Number(repelDepositInput.value).toFixed(3);
    repelHaloLabel.textContent = Number(repelHaloInput.value).toFixed(2);
    repelEvapLabel.textContent = Number(repelEvapInput.value).toFixed(3);
    repelLeakLabel.textContent = Number(repelLeakInput.value).toFixed(4);
    repelWeightLabel.textContent = Number(repelWeightInput.value).toFixed(2);

    explLabel.textContent = Number(explInput.value).toFixed(2);
    sensLabel.textContent = sensorRangeInput.value;
  }

  // find nearest free cell center using perimeter BFS, bounded radius
  function findNearestFreeCell(cx0, cy0, maxRadius=10){
    if (cx0 < 0 || cy0 < 0 || cx0 >= cols || cy0 >= rows) return null;
    if (!obstacles[cx0 + cy0 * cols]) return { cx: cx0, cy: cy0 };
    for (let r = 1; r <= maxRadius; r++){
      for (let dy = -r; dy <= r; dy++){
        for (let dx = -r; dx <= r; dx++){
          if (Math.abs(dx) !== r && Math.abs(dy) !== r) continue;
          const nx = cx0 + dx, ny = cy0 + dy;
          if (nx < 0 || ny < 0 || nx >= cols || ny >= rows) continue;
          const id = nx + ny * cols;
          if (!obstacles[id]) return { cx: nx, cy: ny };
        }
      }
    }
    return null;
  }

  // rescue ant to nearest free cell center (with jitter)
  function rescueAntToNearestFreeCell(a, maxRadius=12){
    const wc = worldToCell(a.x, a.y);
    const nearest = findNearestFreeCell(wc.cx, wc.cy, maxRadius);
    if (!nearest) return false;
    const jitterX = (Math.random() - 0.5) * (cellW * 0.3);
    const jitterY = (Math.random() - 0.5) * (cellH * 0.3);
    a.x = (nearest.cx + 0.5) * cellW + jitterX;
    a.y = (nearest.cy + 0.5) * cellH + jitterY;
    a.angle += Math.PI * (0.4 + Math.random() * 0.6);
    a.x = Math.max(2, Math.min(width-2, a.x));
    a.y = Math.max(2, Math.min(height-2, a.y));
    a.hug = null;
    return true;
  }

  // robust smallest-angle free direction search (short and long radii)
  function findBestFreeDirection(x,y,currentAngle,speed,shortRadius=4,longRadius=10,stepAngle=Math.PI/12,maxSteps=36){
    for (let s = 0; s <= maxSteps; s++){
      const sign = (s % 2 === 0) ? 1 : -1;
      const mag = Math.ceil((s+1)/2);
      const ang = currentAngle + sign * mag * stepAngle;
      const nx1 = x + Math.cos(ang) * Math.max(shortRadius, speed);
      const ny1 = y + Math.sin(ang) * Math.max(shortRadius, speed);
      const c1 = worldToCell(nx1, ny1);
      if (!obstacles[idx(c1.cx, c1.cy)]) return ang;
      const nx2 = x + Math.cos(ang) * Math.max(longRadius, speed*2);
      const ny2 = y + Math.sin(ang) * Math.max(longRadius, speed*2);
      const c2 = worldToCell(nx2, ny2);
      if (!obstacles[idx(c2.cx, c2.cy)]) return ang;
    }
    return null;
  }

  // decide a side for wall hugging: choose left(1) or right(-1) by sampling both sides' local repellent/clearliness
  function chooseHugSide(a){
    // compute perpendicular left and right to vector-to-nest
    const dx = nest.x - a.x, dy = nest.y - a.y;
    const angToNest = Math.atan2(dy, dx);
    const left = angToNest + Math.PI/2;
    const right = angToNest - Math.PI/2;
    const testD = Math.max(6, a.speed*5);
    const leftCell = worldToCell(a.x + Math.cos(left)*testD, a.y + Math.sin(left)*testD);
    const rightCell = worldToCell(a.x + Math.cos(right)*testD, a.y + Math.sin(right)*testD);
    const leftIdx = idx(leftCell.cx, leftCell.cy);
    const rightIdx = idx(rightCell.cx, rightCell.cy);
    const leftBlocked = obstacles[leftIdx];
    const rightBlocked = obstacles[rightIdx];
    // prefer the side that is adjacent to obstacle (so we actually hug)
    if (leftBlocked && !rightBlocked) return 1;
    if (rightBlocked && !leftBlocked) return -1;
    // otherwise pick side with lower local repel mass (prefer clearer)
    const leftRep = Number.isFinite(repel[leftIdx]) ? repel[leftIdx] : 0;
    const rightRep = Number.isFinite(repel[rightIdx]) ? repel[rightIdx] : 0;
    return leftRep <= rightRep ? 1 : -1;
  }

  // wall-hug step: tries to move along contour using small-angle scans biased to chosen side.
  // returns true if a move was made, false otherwise.
  function hugStep(a, side, maxAngOffset=Math.PI*0.9){
    // side: 1 = left-hand hug, -1 = right-hand hug
    // compute a tangent direction around the obstacle: starting angle is perpendicular to nest direction
    const dx = nest.x - a.x, dy = nest.y - a.y;
    const angToNest = Math.atan2(dy, dx);
    // initial tangent direction points along side (perpendicular), but we bias forward slightly
    let baseAng = angToNest + side * Math.PI/2;
    // attempt a sequence of candidate angles around baseAng, stepping toward forward or back depending on side
    const step = Math.PI/18; // 10 degrees
    const maxSteps = Math.round(maxAngOffset / step);
    // order of checking: encourage moving forward along the wall, so check small forward offsets first
    for (let k=0; k<=maxSteps; k++){
      // generate offsets in order: 0, +1, -1, +2, -2, ...
      for (let sgn of [1, -1]){
        const mag = Math.ceil((k+1)/2) * (sgn === 1 ? 1 : -1);
        const ang = baseAng + mag * step * side; // multiply by side to prefer hugging direction
        const nx = a.x + Math.cos(ang) * a.speed;
        const ny = a.y + Math.sin(ang) * a.speed;
        const c = worldToCell(nx, ny);
        const id = idx(c.cx, c.cy);
        // candidate must be free and should be adjacent to at least one obstacle cell (so it hugs)
        if (obstacles[id]) continue;
        // check adjacency to obstacle (8-neighborhood). We prefer cells adjacent to obstacle on the chosen side.
        let adjacentOnSide = false;
        for (let oy=-1; oy<=1; oy++){
          for (let ox=-1; ox<=1; ox++){
            if (ox===0 && oy===0) continue;
            const nxCell = c.cx + ox, nyCell = c.cy + oy;
            if (nxCell < 0 || nyCell < 0 || nxCell >= cols || nyCell >= rows) continue;
            const nId = idx(nxCell, nyCell);
            if (!obstacles[nId]) continue;
            // vector from candidate cell center to obstacle cell center
            const vx = (nxCell + 0.5)*cellW - (c.cx + 0.5)*cellW;
            const vy = (nyCell + 0.5)*cellH - (c.cy + 0.5)*cellH;
            const obsAng = Math.atan2(vy, vx);
            const rel = wrapAngle(obsAng - ang);
            // if obstacle lies roughly on the inner side of our hug (i.e., side direction), mark it
            if (side === 1 && (Math.abs(rel - Math.PI/2) < Math.PI/1.8)) adjacentOnSide = true;
            if (side === -1 && (Math.abs(rel + Math.PI/2) < Math.PI/1.8)) adjacentOnSide = true;
            if (adjacentOnSide) break;
          }
          if (adjacentOnSide) break;
        }
        // If not adjacent on chosen side, still allow move if it's next best (helps in sparse grids)
        // But prefer true adjacency first.
        if (adjacentOnSide){
          a.x = Math.max(2, Math.min(width-2, nx));
          a.y = Math.max(2, Math.min(height-2, ny));
          a.angle = ang;
          return true;
        }
      }
    }
    // if no adjacent-on-side candidate found, try looser moves (any free) in increasing angular offset
    for (let k=0; k<=maxSteps*2; k++){
      const ang = a.angle + ((k%2===0)?1:-1) * Math.ceil((k+1)/2) * step;
      const nx = a.x + Math.cos(ang) * a.speed;
      const ny = a.y + Math.sin(ang) * a.speed;
      const c = worldToCell(nx, ny);
      if (!obstacles[idx(c.cx, c.cy)]){
        a.x = Math.max(2, Math.min(width-2, nx));
        a.y = Math.max(2, Math.min(height-2, ny));
        a.angle = ang;
        return true;
      }
    }
    return false;
  }

  // small helper to wrap angle to -PI..PI
  function wrapAngle(a){
    while (a <= -Math.PI) a += Math.PI*2;
    while (a > Math.PI) a -= Math.PI*2;
    return a;
  }

  // main simulation step
  function stepSim(){
    resizeCanvasAndGrid();

    // read UI
    const carryDeposit = Number(pheromoneDepositInput.value) || 0;
    const baselineDeposit = Number(baselineDepositInput.value) || 0;
    const evap = Number(evapInput.value) || 0.99;
    const leak = Number(leakInput.value) || 0;

    const superDeposit = Number(superDepositInput.value) || 0;
    const superEvap = Number(superEvapInput.value) || 0.995;
    const superLeak = Number(superLeakInput.value) || 0;
    const superWeight = Number(superWeightInput.value) || 0;

    const repelDeposit = Number(repelDepositInput.value) || 0;
    const repelHaloFactor = Number(repelHaloInput.value) || 0.5;
    const repelEvap = Number(repelEvapInput.value) || 0.95;
    const repelLeak = Number(repelLeakInput.value) || 0;
    const repelWeight = Number(repelWeightInput.value) || 1.8;

    const exploration = Number(explInput.value) || 0;
    const sensorRangeUI = Number(sensorRangeInput.value) || 10;

    const diffusionAlpha = 0.08;
    const obstaclePenalty = -1e6;

    // snapshots for sensing (pre-deposition)
    const pherSnap = pher.slice();
    const repelSnap = repel.slice();
    const superSnap = superP.slice();

    for (let a of ants){
      // immediate rescue if inside obstacle cell (rare)
      const curCell = worldToCell(a.x, a.y);
      if (obstacles[idx(curCell.cx, curCell.cy)]){
        const rescued = rescueAntToNearestFreeCell(a, 10);
        if (rescued) {
          // proceed with tick
        }
      }

      // if ant is carrying food, try to follow signals back; if blocked, engage wall-hug controller
      const isCarrying = !!a.carrying;
      const senseRange = isCarrying ? Math.max(6, sensorRangeUI * 1.6) : sensorRangeUI;
      const effectiveExpl = isCarrying ? Math.max(0.02, exploration * 0.12) : exploration;

      // compute current combined signal (snapshot)
      const wc = worldToCell(a.x, a.y);
      const curIdx = idx(wc.cx, wc.cy);
      const curP = Number.isFinite(pherSnap[curIdx]) ? pherSnap[curIdx] : 0;
      const curR = Number.isFinite(repelSnap[curIdx]) ? repelSnap[curIdx] : 0;
      const curS = Number.isFinite(superSnap[curIdx]) ? superSnap[curIdx] : 0;
      const curSignal = superWeight * curS + curP - repelWeight * curR;

      // sense left/center/right conservatively (samples at two distances)
      const lookAngles = [-0.6, 0, 0.6];
      let bestAngle = a.angle;
      let bestDiff = -Infinity;
      for (let la of lookAngles){
        const ang = a.angle + la;
        const sampleDists = [Math.max(2, senseRange * 0.45), Math.max(4, senseRange)];
        let candidateSignal = Infinity;
        for (let dist of sampleDists){
          const tx = a.x + Math.cos(ang) * dist;
          const ty = a.y + Math.sin(ang) * dist;
          const c = worldToCell(tx, ty);
          const idc = idx(c.cx, c.cy);
          if (obstacles[idc]) {
            candidateSignal = Math.min(candidateSignal, obstaclePenalty);
            continue;
          }
          const pVal = Number.isFinite(pherSnap[idc]) ? pherSnap[idc] : 0;
          const rVal = Number.isFinite(repelSnap[idc]) ? repelSnap[idc] : 0;
          const sVal = Number.isFinite(superSnap[idc]) ? superSnap[idc] : 0;
          const sig = superWeight * sVal + pVal - repelWeight * rVal;
          candidateSignal = Math.min(candidateSignal, sig);
        }
        const diff = candidateSignal - curSignal;
        if (diff > bestDiff){
          bestDiff = diff;
          bestAngle = ang;
        }
      }

      // If we are already hugging, attempt a hug step first (this gives continuous contour tracing)
      if (a.hug && a.hug.remaining > 0){
        const moved = hugStep(a, a.hug.side);
        if (!moved){
          // couldn't make a hug step: decrement remaining to allow timeout and maybe rescue
          a.hug.remaining = Math.max(0, a.hug.remaining - 1);
          // if hopeless, rescue
          if (a.hug.remaining === 0){
            rescueAntToNearestFreeCell(a, 12);
          }
        } else {
          // record last positions to detect loops
          a.hug.lastPositions = a.hug.lastPositions || [];
          a.hug.lastPositions.push({x: Math.round(a.x), y: Math.round(a.y)});
          if (a.hug.lastPositions.length > 8) a.hug.lastPositions.shift();
          // if the hug has looped (same cell seen multiple times) reduce remaining to force timeout
          const counts = {};
          for (let p of a.hug.lastPositions) counts[p.x + ',' + p.y] = (counts[p.x + ',' + p.y] || 0) + 1;
          for (let k in counts) if (counts[k] > 2) a.hug.remaining = Math.max(0, a.hug.remaining - 2);
        }
      } else {
        // No active hug: normal movement decision
        if (bestDiff > 0 && Math.random() > effectiveExpl){
          const jitter = isCarrying ? 0.10 : 0.25;
          a.angle = bestAngle + (Math.random()-0.5) * jitter;
        } else {
          if (isCarrying && bestDiff <= 0){
            // direct homing check
            const dxn = nest.x - a.x, dyn = nest.y - a.y;
            const angToNest = Math.atan2(dyn, dxn);
            // test a cell a bit ahead toward nest
            const nxTest = a.x + Math.cos(angToNest) * Math.max(6, a.speed*3);
            const nyTest = a.y + Math.sin(angToNest) * Math.max(6, a.speed*3);
            const tcell = worldToCell(nxTest, nyTest);
            const tIdx = idx(tcell.cx, tcell.cy);

            if (!obstacles[tIdx]){
              // clear path — home
              a.angle = angToNest + (Math.random()-0.5) * 0.25;
            } else {
              // blocked: start wall-hug mode
              const side = chooseHugSide(a); // 1 left, -1 right
              a.hug = {
                side: side,
                remaining: Math.max(10, Math.round(sensorRangeUI * 1.8)),
                lastPositions: []
              };
              // perform an immediate hug step to avoid stuckness
              const moved = hugStep(a, side);
              if (!moved){
                // attempt robust escape direction or rescue
                const alt = findBestFreeDirection(a.x, a.y, a.angle, a.speed);
                if (alt !== null){
                  a.angle = alt;
                  const nx2 = a.x + Math.cos(a.angle) * a.speed;
                  const ny2 = a.y + Math.sin(a.angle) * a.speed;
                  if (!obstacles[idx(worldToCell(nx2, ny2).cx, worldToCell(nx2, ny2).cy)]) {
                    a.x = Math.max(2, Math.min(width-2, nx2));
                    a.y = Math.max(2, Math.min(height-2, ny2));
                  } else {
                    rescueAntToNearestFreeCell(a, 12);
                  }
                } else {
                  rescueAntToNearestFreeCell(a, 12);
                }
              }
            }
          } else {
            // exploring random walk
            a.angle += (Math.random()-0.5) * 0.8;
          }
        }

        // normal move attempt if not placed by hugStep
        if (!(a.hug && a.hug.remaining < 999 && a.hug.lastPositions && a.hug.lastPositions.length && a.hug.remaining > 0)){
          // attempt move
          let nx = a.x + Math.cos(a.angle) * a.speed;
          let ny = a.y + Math.sin(a.angle) * a.speed;
          const c = worldToCell(nx, ny);
          const cIdx = idx(c.cx, c.cy);
          if (obstacles[cIdx]){
            // deposit repellent + halo
            if (cIdx >= 0 && cIdx < repel.length){
              const add = repelDeposit;
              repel[cIdx] = (Number.isFinite(repel[cIdx]) ? repel[cIdx] + add : add);
              totalRepelDeposits += add;
            }
            wallHitCount++;
            if (repelHaloFactor > 0){
              const cx = Math.max(0, Math.min(cols-1, c.cx));
              const cy = Math.max(0, Math.min(rows-1, c.cy));
              for (let oy=-1; oy<=1; oy++){
                for (let ox=-1; ox<=1; ox++){
                  const nxCell = cx + ox, nyCell = cy + oy;
                  if (nxCell < 0 || nyCell < 0 || nxCell >= cols || nyCell >= rows) continue;
                  const nId = nxCell + nyCell * cols;
                  if (obstacles[nId]) continue;
                  const add = repelDeposit * repelHaloFactor;
                  repel[nId] = (Number.isFinite(repel[nId]) ? repel[nId] + add : add);
                  totalRepelDeposits += add;
                }
              }
            }
            // robust alternative
            const alt = findBestFreeDirection(a.x, a.y, a.angle, a.speed);
            if (alt !== null){
              a.angle = alt;
              const nx2 = a.x + Math.cos(a.angle) * a.speed;
              const ny2 = a.y + Math.sin(a.angle) * a.speed;
              const c2 = worldToCell(nx2, ny2);
              if (!obstacles[idx(c2.cx, c2.cy)]){
                a.x = Math.max(2, Math.min(width-2, nx2));
                a.y = Math.max(2, Math.min(height-2, ny2));
              } else {
                rescueAntToNearestFreeCell(a, 12);
              }
            } else {
              rescueAntToNearestFreeCell(a, 12);
            }
          } else {
            a.x = Math.max(2, Math.min(width-2, nx));
            a.y = Math.max(2, Math.min(height-2, ny));
          }
        }
      } // end not hugging block (if hugging was active, hugStep already moved them)

      // pickup/drop & beacon deposit
      const dFood = Math.hypot(a.x - food.x, a.y - food.y);
      if (!a.carrying && dFood < 6){
        a.carrying = true;
        const wc2 = worldToCell(a.x, a.y);
        const id = idx(wc2.cx, wc2.cy);
        if (id >= 0 && id < superP.length){
          const add = superDeposit;
          superP[id] = (Number.isFinite(superP[id]) ? superP[id] + add : add);
          totalBeaconDeposits += add;
        }
      }
      const dNest = Math.hypot(a.x - nest.x, a.y - nest.y);
      if (a.carrying && dNest < 8){
        a.carrying = false;
        a.hug = null;
      }

      // deposition baseline + carry
      const wc3 = worldToCell(a.x, a.y);
      const id3 = idx(wc3.cx, wc3.cy);
      if (id3 >= 0 && id3 < pher.length){
        if (baselineDeposit > 0) pher[id3] = (Number.isFinite(pher[id3]) ? pher[id3] + baselineDeposit : baselineDeposit);
        if (a.carrying) pher[id3] = (Number.isFinite(pher[id3]) ? pher[id3] + carryDeposit : carryDeposit);
      }
    } // end ants loop

    // evaporation (apply to live arrays)
    for (let i=0;i<pher.length;i++){
      let v = Number.isFinite(pher[i]) ? pher[i] : 0;
      v = v * evap - leak;
      if (!Number.isFinite(v) || v <= 0) v = 0;
      pher[i] = v;
    }
    for (let i=0;i<superP.length;i++){
      let v = Number.isFinite(superP[i]) ? superP[i] : 0;
      v = v * superEvap - superLeak;
      if (!Number.isFinite(v) || v <= 0) v = 0;
      superP[i] = v;
    }
    for (let i=0;i<repel.length;i++){
      let v = Number.isFinite(repel[i]) ? repel[i] : 0;
      v = v * repelEvap - repelLeak;
      if (!Number.isFinite(v) || v <= 0) v = 0;
      repel[i] = v;
    }

    // diffusion (gentle)
    const pcopy = pher.slice(), scap = superP.slice(), rcopy = repel.slice();
    for (let y=0;y<rows;y++){
      for (let x=0;x<cols;x++){
        const id = x + y * cols;
        let psum = pcopy[id], pcount = 1;
        let ssum = scap[id], scount = 1;
        let rsum = rcopy[id], rcount = 1;
        if (x>0){ psum += pcopy[id-1]; pcount++; ssum += scap[id-1]; scount++; rsum += rcopy[id-1]; rcount++; }
        if (x<cols-1){ psum += pcopy[id+1]; pcount++; ssum += scap[id+1]; scount++; rsum += rcopy[id+1]; rcount++; }
        if (y>0){ psum += pcopy[id-cols]; pcount++; ssum += scap[id-cols]; scount++; rsum += rcopy[id-cols]; rcount++; }
        if (y<rows-1){ psum += pcopy[id+cols]; pcount++; ssum += scap[id+cols]; scount++; rsum += rcopy[id+cols]; rcount++; }
        const pavg = psum / pcount, savg = ssum / scount, ravg = rsum / rcount;
        const alpha = diffusionAlpha;
        let newp = (Number.isFinite(pcopy[id]) ? pcopy[id] : 0) * (1 - alpha) + pavg * alpha;
        let news = (Number.isFinite(scap[id]) ? scap[id] : 0) * (1 - alpha) + savg * alpha;
        let newr = (Number.isFinite(rcopy[id]) ? rcopy[id] : 0) * (1 - alpha) + ravg * alpha;
        if (!Number.isFinite(newp) || newp <= 0) newp = 0;
        if (!Number.isFinite(news) || news <= 0) news = 0;
        if (!Number.isFinite(newr) || newr <= 0) newr = 0;
        pher[id] = newp;
        superP[id] = news;
        repel[id] = newr;
      }
    }

    // diagnostics
    let trailMass = 0, beaconMass = 0, repelMass = 0;
    for (let i=0;i<pher.length;i++) trailMass += (Number.isFinite(pher[i]) ? pher[i] : 0);
    for (let i=0;i<superP.length;i++) beaconMass += (Number.isFinite(superP[i]) ? superP[i] : 0);
    for (let i=0;i<repel.length;i++) repelMass += (Number.isFinite(repel[i]) ? repel[i] : 0);

    trailMassElm.textContent = trailMass.toFixed(6);
    beaconMassElm.textContent = beaconMass.toFixed(6);
    repelMassElm.textContent = repelMass.toFixed(6);
    wallHitsElm.textContent = wallHitCount;
    beaconDepositsElm.textContent = totalBeaconDeposits.toFixed(3);
    repelDepositsElm.textContent = totalRepelDeposits.toFixed(3);
  }

  // draw (auto-normalize)
  function draw(){
    resizeCanvasAndGrid();
    ctx.clearRect(0,0,width,height);

    let maxTrail = 0, maxSuper = 0, maxRepel = 0;
    for (let i=0;i<pher.length;i++){
      const pv = Number.isFinite(pher[i]) ? pher[i] : 0;
      if (pv > maxTrail) maxTrail = pv;
      const sv = Number.isFinite(superP[i]) ? superP[i] : 0;
      if (sv > maxSuper) maxSuper = sv;
      const rv = Number.isFinite(repel[i]) ? repel[i] : 0;
      if (rv > maxRepel) maxRepel = rv;
    }

    // trail
    for (let y=0;y<rows;y++){
      for (let x=0;x<cols;x++){
        const i = x + y * cols;
        const v = Number.isFinite(pher[i]) ? pher[i] : 0;
        if (v > 0){
          const alpha = Math.min(1, v / (maxTrail || 1) * 0.9);
          ctx.fillStyle = `rgba(255,165,0,${alpha})`;
          ctx.fillRect(x*cellW, y*cellH, cellW, cellH);
        }
      }
    }
    // super
    for (let y=0;y<rows;y++){
      for (let x=0;x<cols;x++){
        const i = x + y * cols;
        const v = Number.isFinite(superP[i]) ? superP[i] : 0;
        if (v > 0){
          const alpha = Math.min(1, v / (maxSuper || 1) * 0.95);
          ctx.fillStyle = `rgba(200,90,255,${alpha})`;
          ctx.fillRect(x*cellW, y*cellH, cellW, cellH);
        }
      }
    }
    // repellent
    for (let y=0;y<rows;y++){
      for (let x=0;x<cols;x++){
        const i = x + y * cols;
        const v = Number.isFinite(repel[i]) ? repel[i] : 0;
        if (v > 0){
          const alpha = Math.min(0.9, v / (maxRepel || 1) * 0.9);
          ctx.fillStyle = `rgba(60,150,255,${alpha})`;
          ctx.fillRect(x*cellW, y*cellH, cellW, cellH);
        }
      }
    }

    // obstacles
    ctx.fillStyle = '#333';
    for (let y=0;y<rows;y++){
      for (let x=0;x<cols;x++){
        if (obstacles[x + y*cols]) ctx.fillRect(x*cellW, y*cellH, cellW, cellH);
      }
    }

    // nest & food
    ctx.beginPath(); ctx.fillStyle = 'lime'; ctx.arc(nest.x, nest.y, 10, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.fillStyle = 'crimson'; ctx.arc(food.x, food.y, 10, 0, Math.PI*2); ctx.fill();

    // ants + hug markers
    for (let a of ants){
      ctx.beginPath();
      ctx.fillStyle = a.carrying ? 'yellow' : 'white';
      ctx.arc(a.x, a.y, 3, 0, Math.PI*2);
      ctx.fill();
      if (a.hug && a.hug.remaining > 0){
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(255,255,255,0.75)';
        ctx.moveTo(a.x, a.y);
        const hx = a.x + Math.cos(a.angle)*8;
        const hy = a.y + Math.sin(a.angle)*8;
        ctx.lineTo(hx, hy);
        ctx.stroke();
        // side indicator
        ctx.beginPath();
        ctx.fillStyle = a.hug.side === 1 ? 'rgba(0,255,128,0.6)' : 'rgba(255,80,80,0.6)';
        ctx.arc(a.x + Math.cos(a.angle + Math.PI/2 * a.hug.side)*6, a.y + Math.sin(a.angle + Math.PI/2 * a.hug.side)*6, 2, 0, Math.PI*2);
        ctx.fill();
      }
    }
  }

  // main loop
  let running = true;
  function loop(){
    if (running){
      const desired = Number(numAntsInput.value) || 100;
      if (ants.length < desired) resetAnts(desired);
      else if (ants.length > desired) ants.length = desired;
      stepSim();
      draw();
    }
    requestAnimationFrame(loop);
  }

  // init / reset
  function resetAll(){
    resizeCanvasAndGrid();
    allocFields();
    placeDefaults();
    resetObstaclesDefault();
    resetAnts(Number(numAntsInput.value) || 120);
    wallHitCount = 0;
    totalBeaconDeposits = 0;
    totalRepelDeposits = 0;
  }
  resetAll();
  requestAnimationFrame(loop);

  // mouse interactions (draw obstacles, place food)
  let drawing = false;
  canvas.addEventListener('pointerdown', (e) => { drawing = true; drawObstacleAt(e); });
  canvas.addEventListener('pointermove', (e) => { if (drawing) drawObstacleAt(e); });
  window.addEventListener('pointerup', () => drawing = false);
  function drawObstacleAt(e){
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const c = worldToCell(x, y);
    const id = idx(c.cx, c.cy);
    if (id >= 0 && id < obstacles.length) obstacles[id] = 1;
  }
  canvas.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    food.x = x; food.y = y;
  });

  // UI bindings
  const uiElems = [numAntsInput, pheromoneDepositInput, baselineDepositInput, evapInput, leakInput,
                   superDepositInput, superEvapInput, superLeakInput, superWeightInput,
                   repelDepositInput, repelHaloInput, repelEvapInput, repelLeakInput, repelWeightInput,
                   explInput, sensorRangeInput];
  uiElems.forEach(el => el.addEventListener('input', updateLabels));
  resetBtn.addEventListener('click', () => { resetAll(); });
  toggleSim.addEventListener('click', () => { running = !running; toggleSim.textContent = running ? 'Pause' : 'Resume'; });

  updateLabels();
  resizeCanvasAndGrid();
})();
</script>
</body>
</html>
